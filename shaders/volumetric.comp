#version 450
#extension GL_ARB_separate_shader_objects : enable

struct Particle {
    vec4 position;
    vec3 velocity;
    vec4 color;
};

layout(binding = 0, rgba8) uniform image2D storageTexture;

layout (binding = 1) uniform ParameterUBO {
    float deltaTime;
    float totalTime;
    vec3 sunPosition;
    vec3 cameraPosition;
    int frame;
} ubo;

layout(std140, binding = 2) buffer ParticleSSBO {
    Particle particles[];
};

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

// contains sdf value and gradient but also particle color
struct LiquiSDD {
    float val;
    vec3 grad;
    vec3 col;
};

/* SHADER PARAMS */
// particles
int particleCount = 64;      // particle count
// light data
vec3 lightColor = vec3(1,1,1);         // light color
vec3 ambientLight = vec3(1,1,1);       // ambient light color
float ambientFactor = 0.25;            // intensity of ambient light
float diffuseFactor = 1.0;             // intensity of diffuse light
float specularFactor = 0.75;            // intensity of specular light
float intensity = 32.0;                 // more intensity, means more energy, giving it more reach
// liquid properties
float density = 0.25;               // global density of liquid, used to determine step size and beer lambert calculation
float viscosity = 1.75;             // determines how close particles need to be until they (dis)connect
float refractionFactor = 1.33;      // refraction factor of the liquid (water = 1.33, air = 1.0)
float waterShininess = 100.0;       // determines the shininess in the specular term for water
float energyAbsorption = 0.5;      // water absorption coefficient

// create sdf for a sphere
// (sdf.x, gradient.yzw)
LiquiSDD sdSphere(in vec3 p, in vec3 c, in float r, in vec3 color)
{
    LiquiSDD liquid;
    liquid.val = length(p - c) - r;
    liquid.grad = normalize(p - c);
    liquid.col = color;
    return liquid;
}

LiquiSDD sdDisplacement(in vec3 p, in LiquiSDD liq, in float height)
{
    float frequency = 15.0;
    LiquiSDD liquid;
    liquid.val = liq.val + sin(p.x * frequency) * sin(p.y * frequency) * sin(p.z * frequency) * height;
    float gradX = cos(p.x * frequency) * sin(p.y * frequency) * sin(p.z * frequency) * height;
    float gradY = sin(p.x * frequency) * cos(p.y * frequency) * sin(p.z * frequency) * height;
    float gradZ = sin(p.x * frequency) * sin(p.y * frequency) * cos(p.z * frequency) * height;
    liquid.grad = liq.grad + vec3(gradX, gradY, gradZ);
    liquid.col = liq.col;
    return liquid;
}

// combine two sdfs with union
LiquiSDD sdUnion(in LiquiSDD liq1, in LiquiSDD liq2)
{
    LiquiSDD res;
    res.val = min(liq1.val, liq2.val);
    res.grad = (liq1.val < liq2.val) ? liq1.grad : liq2.grad;
    res.col = (liq1.val < liq2.val) ? liq1.col : liq2.col;
    return res;
}

// smooth minimum - https://iquilezles.org/articles/smin/
// returns: vec2 (sdf value, mix factor)
vec2 sminN( float a, float b, float k, float n )
{
    float h = max( k-abs(a-b), 0.0 )/k;
    float m = pow(h, n)*0.5;
    float s = m*k/n; 
    return (a<b) ? vec2(a-s,m) : vec2(b-s,1.0-m);
}

LiquiSDD sdSmoothUnion(in LiquiSDD liq1, in LiquiSDD liq2, in float k, in float n)
{
    LiquiSDD res;
    vec2 smoothRes = sminN(liq1.val, liq2.val, k, n);
    res.val = smoothRes.x;
    res.grad = normalize(mix(liq1.grad, liq2.grad, smoothRes.y));
    res.col = mix(liq1.col, liq2.col, smoothRes.y);
    return res;
}

// This is where we create our SDF and sample it with the current position
LiquiSDD map(in vec3 p)
{
    // there seems to be something wrong with the particle buffer so let's do it manually
    // 5x5 grid of particles/spheres moving up and down
    float particleSize = 0.5;
    vec3 waterColor = vec3(0.0,0.125,0.5);

    LiquiSDD liq = sdSphere(p, vec3(-2.,cos(ubo.totalTime+4.)*0.25,-2.), particleSize, waterColor);

    liq = sdSmoothUnion(liq, sdSphere(p, vec3(-1.,cos(ubo.totalTime+3.)*0.25,-2.), particleSize, waterColor), 0.5, viscosity);
    liq = sdSmoothUnion(liq, sdSphere(p, vec3(0,cos(ubo.totalTime+2.)*0.25,-2.), particleSize, waterColor), 0.5, viscosity);
    liq = sdSmoothUnion(liq, sdSphere(p, vec3(1.,cos(ubo.totalTime+3.)*0.25,-2.), particleSize, waterColor), 0.5, viscosity);
    liq = sdSmoothUnion(liq, sdSphere(p, vec3(2.,cos(ubo.totalTime+4.)*0.25,-2.), particleSize, waterColor), 0.5, viscosity);

    liq = sdSmoothUnion(liq, sdSphere(p, vec3(-2.,cos(ubo.totalTime+3.)*0.25,-1.), particleSize, waterColor), 0.5, viscosity);
    liq = sdSmoothUnion(liq, sdSphere(p, vec3(-1.,cos(ubo.totalTime+2.)*0.25,-1.), particleSize, waterColor), 0.5, viscosity);
    liq = sdSmoothUnion(liq, sdSphere(p, vec3(0,cos(ubo.totalTime+1.)*0.25,-1.), particleSize, waterColor), 0.5, viscosity);
    liq = sdSmoothUnion(liq, sdSphere(p, vec3(1.,cos(ubo.totalTime+2.)*0.25,-1.), particleSize, waterColor), 0.5, viscosity);
    liq = sdSmoothUnion(liq, sdSphere(p, vec3(2.,cos(ubo.totalTime+3.)*0.25,-1.), particleSize, waterColor), 0.5, viscosity);

    liq = sdSmoothUnion(liq, sdSphere(p, vec3(-2.,cos(ubo.totalTime+2.)*0.25,0.), particleSize, waterColor), 0.5, viscosity);
    liq = sdSmoothUnion(liq, sdSphere(p, vec3(-1.,cos(ubo.totalTime+1.)*0.25,0.), particleSize, waterColor), 0.5, viscosity);
    liq = sdSmoothUnion(liq, sdSphere(p, vec3(0, cos(ubo.totalTime)*0.25,0.), particleSize, waterColor), 0.5, viscosity);
    liq = sdSmoothUnion(liq, sdSphere(p, vec3(1.,cos(ubo.totalTime+1.)*0.25,0.), particleSize, waterColor), 0.5, viscosity);
    liq = sdSmoothUnion(liq, sdSphere(p, vec3(2.,cos(ubo.totalTime+2.)*0.25,0.), particleSize, waterColor), 0.5, viscosity);

    liq = sdSmoothUnion(liq, sdSphere(p, vec3(-2.,cos(ubo.totalTime+3.)*0.25,1.), particleSize, waterColor), 0.5, viscosity);
    liq = sdSmoothUnion(liq, sdSphere(p, vec3(-1.,cos(ubo.totalTime+2.)*0.25,1.), particleSize, waterColor), 0.5, viscosity);
    liq = sdSmoothUnion(liq, sdSphere(p, vec3(0,cos(ubo.totalTime+1.)*0.25,1.), particleSize, waterColor), 0.5, viscosity);
    liq = sdSmoothUnion(liq, sdSphere(p, vec3(1.,cos(ubo.totalTime+2.)*0.25,1.), particleSize, waterColor), 0.5, viscosity);
    liq = sdSmoothUnion(liq, sdSphere(p, vec3(2.,cos(ubo.totalTime+3.)*0.25,1.), particleSize, waterColor), 0.5, viscosity);

    liq = sdSmoothUnion(liq, sdSphere(p, vec3(-2.,cos(ubo.totalTime+4.)*0.25,2.), particleSize, waterColor), 0.5, viscosity);
    liq = sdSmoothUnion(liq, sdSphere(p, vec3(-1.,cos(ubo.totalTime+3.)*0.25,2.), particleSize, waterColor), 0.5, viscosity);
    liq = sdSmoothUnion(liq, sdSphere(p, vec3(0,cos(ubo.totalTime+2.)*0.25,2.), particleSize, waterColor), 0.5, viscosity);
    liq = sdSmoothUnion(liq, sdSphere(p, vec3(1.,cos(ubo.totalTime+3.)*0.25,2.), particleSize, waterColor), 0.5, viscosity);
    liq = sdSmoothUnion(liq, sdSphere(p, vec3(2.,cos(ubo.totalTime+4.)*0.25,2.), particleSize, waterColor), 0.5, viscosity);
    return sdDisplacement(p, liq, 0.03125);
/*
    // start with the first particle
    LiquiSDD liq = sdSphere(p, particles[0].position.xyz, particles[0].position.w, particles[0].color.rgb);
    // how many particles?
    // combining all particles
    for(int i = 1; i < particleCount; i++)
    {
        // note, the k and n value change how smoothmin behaves, these values also allow us to simulate the viscosity
        // higher n means it can stretch further
        liq = sdSmoothUnion(liq, sdSphere(p, particles[i].position.xyz, particles[1].position.w, particles[i].color.rgb), 0.5, viscosity);
    }
    return liq;*/
 }

 // calculates beer lambert law
 float BeerLambert(float absorptionCoefficient, float distanceTraveled)
{
    return exp(-absorptionCoefficient * distanceTraveled);
}

// get a sky color based on the ray direction
vec3 getSkyColor(in vec3 rd)
{
    if(rd.y <= 0)
    {
        return vec3(1.0, 1.0, 1.0);
    }
    else if(rd.y > 0)
    {
        return vec3(0.8, 0.8, 0.0);
    }
}

vec3 ray_march(in vec3 ro, in vec3 rd)
{
    float total_distance_traveled = 0.0;
    float curr_distance_traveled = 0.0;
    const int NUMBER_OF_STEPS = 1024;
    const float MINIMUM_HIT_DISTANCE = 0.001;
    const float MAXIMUM_TRACE_DISTANCE = 1000.0;

    float unabsorbedEnergy = 1.f;

    vec3 color = vec3(0,0,0);
    bool inside = false;

    for (int i = 0; i < NUMBER_OF_STEPS; ++i)
    {
        vec3 current_position = ro + curr_distance_traveled * rd;

        LiquiSDD liq = map(current_position);
        float distance_to_closest = liq.val;

        if (distance_to_closest < MINIMUM_HIT_DISTANCE)
        {
            // entered first time
            if(!inside)
            {
                curr_distance_traveled = 0.0;
                // we now go down a new ray, the refracted ray, so we need to update our origin position
                ro = current_position;
                // refraction param: air=1.0, water=1.33, curr_medium / next_medium
                rd = refract(rd, liq.grad, 1. / refractionFactor);
                inside = true;
                // specular, reflection
                vec3 reflection = reflect(rd, liq.grad);
                color += specularFactor * pow(max(0., dot(reflection, normalize(sunPosition - current_position))), waterShininess) * lightColor;
            }
            float prevRestEnergy = unabsorbedEnergy;
            unabsorbedEnergy *= BeerLambert(energyAbsorption, density);

            total_distance_traveled += density;
            curr_distance_traveled += density;
            float absorptionThisStep = prevRestEnergy - unabsorbedEnergy;
            // diffuse light
            float distToLight = length(sunPosition - current_position);
            vec3 currLightColor = lightColor * intensity / distToLight; // attenuation function: 1/dist
            color += diffuseFactor * liq.col * currLightColor * absorptionThisStep;
            // ambient light
            color += ambientFactor * liq.col * ambientLight * absorptionThisStep;
            if(unabsorbedEnergy <= 0.f) 
            {
                break;
            }
        }
        else if( total_distance_traveled > MAXIMUM_TRACE_DISTANCE)
        {
            return (1. - unabsorbedEnergy) * color + (unabsorbedEnergy) * getSkyColor(rd);
        }
        else
        {
            total_distance_traveled += distance_to_closest;
            curr_distance_traveled += distance_to_closest;
            // refract when leaving
            if(inside)
            {
                // refraction param: air=1.0, water=1.33, curr_medium / next_medium, water => air
                rd = refract(rd, liq.grad, refractionFactor);
                inside = false;
            }
        }
        
    }
    return color;
}

void main() {
    vec2 screenSize = imageSize(storageTexture);
    float horizontalCoefficient = (2.0 * float(gl_GlobalInvocationID.x) / screenSize.x) - 1.0;
    float verticalCoefficient = (2.0 * float(gl_GlobalInvocationID.y) / screenSize.y) - 1.0;

    vec3 ro = cameraPosition;
    vec3 rd = normalize(vec3(horizontalCoefficient, verticalCoefficient, 1.0));

    vec3 color = ray_march(ro, rd);

    imageStore(storageTexture, ivec2(gl_GlobalInvocationID.xy), vec4(color, 1.0));
}