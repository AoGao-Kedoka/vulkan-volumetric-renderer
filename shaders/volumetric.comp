#version 450

#include "utils.glsl"

struct Particle {
    vec4 position;
    vec3 velocity;
    vec4 color;
};

layout(binding = 0, rgba8) uniform image2D storageTexture;

layout (binding = 1) uniform ParameterUBO {
    float deltaTime;
    float totalTime;
    vec3 sunPosition;
    vec3 cameraPosition;
    int frame;
} ubo;

layout(std140, binding = 2) buffer ParticleSSBO {
    Particle particles[];
};

layout (binding = 5, rgba8) uniform image2D causticTexture;

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

// contains sdf value and gradient but also particle color
struct LiquiSDD {
    float val;
    vec3 grad;
    vec3 col;
};

/* SHADER PARAMS */
// particles
int particleCount = 64;      // particle count
// light data
vec3 lightColor = vec3(1,1,1);         // light color
vec3 ambientLight = vec3(1,1,1);       // ambient light color
float ambientFactor = 0.25;            // intensity of ambient light
float diffuseFactor = 1.0;             // intensity of diffuse light
float specularFactor = 0.25;            // intensity of specular light
float intensity = 32.0;                 // more intensity, means more energy, giving it more reach
// liquid properties
float density = 0.25;               // global density of liquid, used to determine step size and beer lambert calculation
float viscosity = 1.75;             // determines how close particles need to be until they (dis)connect
float refractionFactor = 1.33;      // refraction factor of the liquid (water = 1.33, air = 1.0)
float waterShininess = 80.0;       // determines the shininess in the specular term for water
float energyAbsorption = 0.03;      // water absorption coefficient

// create sdf for a sphere
// (sdf.x, gradient.yzw)
LiquiSDD sdSphere(in vec3 p, in vec3 c, in float r, in vec3 color)
{
    LiquiSDD liquid;
    liquid.val = length(p - c) - r;
    liquid.grad = normalize(p - c);
    liquid.col = color;
    return liquid;
}

LiquiSDD sdDisplacement(in vec3 p, in LiquiSDD liq, in float height)
{
    // add some animation
    float frequencyX = 8.0 + sin(ubo.totalTime), frequencyY = 9.0 + sin(ubo.totalTime), frequencyZ = 8.5 + sin(ubo.totalTime);
    LiquiSDD liquid;
    liquid.val = liq.val + (1. - pow(sin((p.x + 3.) * frequencyX) * sin((p.y + 3.) * frequencyY) * sin((p.z + 3.) * frequencyZ), 2.)) * height;
    float outer = -2. * sin((p.x + 3.) * frequencyX) * sin((p.y + 3.) * frequencyY) * sin((p.z + 3.) * frequencyZ) * height;
    float gradX = outer * frequencyX * cos((p.x + 3.) * frequencyX) * sin((p.y + 3.) * frequencyY) * sin((p.z + 3.) * frequencyZ);
    float gradY = outer * frequencyY * sin((p.x + 3.) * frequencyX) * cos((p.y + 3.) * frequencyY) * sin((p.z + 3.) * frequencyZ);
    float gradZ = outer * frequencyZ * sin((p.x + 3.) * frequencyX) * sin((p.y + 3.) * frequencyY) * cos((p.z + 3.) * frequencyZ);
    liquid.grad = normalize(liq.grad + vec3(gradX, gradY, gradZ));
    liquid.col = liq.col;
    return liquid;
}

// combine two sdfs with union
LiquiSDD sdUnion(in LiquiSDD liq1, in LiquiSDD liq2)
{
    LiquiSDD res;
    res.val = min(liq1.val, liq2.val);
    res.grad = (liq1.val < liq2.val) ? liq1.grad : liq2.grad;
    res.col = (liq1.val < liq2.val) ? liq1.col : liq2.col;
    return res;
}


LiquiSDD sdSmoothUnion(in LiquiSDD liq1, in LiquiSDD liq2, in float k, in float n)
{
    LiquiSDD res;
    vec2 smoothRes = sminN(liq1.val, liq2.val, k, n);
    res.val = smoothRes.x;
    res.grad = normalize(mix(liq1.grad, liq2.grad, smoothRes.y));
    res.col = mix(liq1.col, liq2.col, smoothRes.y);
    return res;
}

float Caustic(vec3 position){
    float noise = 20 * fbm_4(position / 15.0 + ubo.totalTime / 3.0);
    float waterNoise = fract(noise);
    float causticMultiplier = 7.0;
    return causticMultiplier * 0.027 *  pow(
                smoothVoronoi(position.xz / 4.0 +
                          vec2(ubo.totalTime, ubo.totalTime+ 3.0) +
                          3.0 * vec2(cos(waterNoise), sin(waterNoise))), 5.0);
}

// This is where we create our SDF and sample it with the current position
LiquiSDD map(in vec3 p)
{
    // there seems to be something wrong with the particle buffer so let's do it manually
    // 5x5 grid of particles/spheres moving up and down
    float particleSize = 0.66;
    vec3 waterColor = vec3(0.0,0.125,0.5);

    LiquiSDD liq = sdSphere(p, vec3(-2.,cos(ubo.totalTime+4.)*0.25,-2.), particleSize, waterColor);
    liq = sdSmoothUnion(liq, sdSphere(p, vec3(-1.,cos(ubo.totalTime+3.)*0.25,-2.), particleSize, waterColor), 0.5, viscosity);
    liq = sdSmoothUnion(liq, sdSphere(p, vec3(0,cos(ubo.totalTime+2.)*0.25,-2.), particleSize, waterColor), 0.5, viscosity);
    liq = sdSmoothUnion(liq, sdSphere(p, vec3(1.,cos(ubo.totalTime+3.)*0.25,-2.), particleSize, waterColor), 0.5, viscosity);
    liq = sdSmoothUnion(liq, sdSphere(p, vec3(2.,cos(ubo.totalTime+4.)*0.25,-2.), particleSize, waterColor), 0.5, viscosity);

    liq = sdSmoothUnion(liq, sdSphere(p, vec3(-2.,cos(ubo.totalTime+3.)*0.25,-1.), particleSize, waterColor), 0.5, viscosity);
    liq = sdSmoothUnion(liq, sdSphere(p, vec3(-1.,cos(ubo.totalTime+2.)*0.25,-1.), particleSize, waterColor), 0.5, viscosity);
    liq = sdSmoothUnion(liq, sdSphere(p, vec3(0,cos(ubo.totalTime+1.)*0.25,-1.), particleSize, waterColor), 0.5, viscosity);
    liq = sdSmoothUnion(liq, sdSphere(p, vec3(1.,cos(ubo.totalTime+2.)*0.25,-1.), particleSize, waterColor), 0.5, viscosity);
    liq = sdSmoothUnion(liq, sdSphere(p, vec3(2.,cos(ubo.totalTime+3.)*0.25,-1.), particleSize, waterColor), 0.5, viscosity);

    liq = sdSmoothUnion(liq, sdSphere(p, vec3(-2.,cos(ubo.totalTime+2.)*0.25,0.), particleSize, waterColor), 0.5, viscosity);
    liq = sdSmoothUnion(liq, sdSphere(p, vec3(-1.,cos(ubo.totalTime+1.)*0.25,0.), particleSize, waterColor), 0.5, viscosity);
    liq = sdSmoothUnion(liq, sdSphere(p, vec3(0, cos(ubo.totalTime)*0.25,0.), particleSize, waterColor), 0.5, viscosity);
    liq = sdSmoothUnion(liq, sdSphere(p, vec3(1.,cos(ubo.totalTime+1.)*0.25,0.), particleSize, waterColor), 0.5, viscosity);
    liq = sdSmoothUnion(liq, sdSphere(p, vec3(2.,cos(ubo.totalTime+2.)*0.25,0.), particleSize, waterColor), 0.5, viscosity);

    liq = sdSmoothUnion(liq, sdSphere(p, vec3(-2.,cos(ubo.totalTime+3.)*0.25,1.), particleSize, waterColor), 0.5, viscosity);
    liq = sdSmoothUnion(liq, sdSphere(p, vec3(-1.,cos(ubo.totalTime+2.)*0.25,1.), particleSize, waterColor), 0.5, viscosity);
    liq = sdSmoothUnion(liq, sdSphere(p, vec3(0,cos(ubo.totalTime+1.)*0.25,1.), particleSize, waterColor), 0.5, viscosity);
    liq = sdSmoothUnion(liq, sdSphere(p, vec3(1.,cos(ubo.totalTime+2.)*0.25,1.), particleSize, waterColor), 0.5, viscosity);
    liq = sdSmoothUnion(liq, sdSphere(p, vec3(2.,cos(ubo.totalTime+3.)*0.25,1.), particleSize, waterColor), 0.5, viscosity);

    liq = sdSmoothUnion(liq, sdSphere(p, vec3(-2.,cos(ubo.totalTime+4.)*0.25,2.), particleSize, waterColor), 0.5, viscosity);
    liq = sdSmoothUnion(liq, sdSphere(p, vec3(-1.,cos(ubo.totalTime+3.)*0.25,2.), particleSize, waterColor), 0.5, viscosity);
    liq = sdSmoothUnion(liq, sdSphere(p, vec3(0,cos(ubo.totalTime+2.)*0.25,2.), particleSize, waterColor), 0.5, viscosity);
    liq = sdSmoothUnion(liq, sdSphere(p, vec3(1.,cos(ubo.totalTime+3.)*0.25,2.), particleSize, waterColor), 0.5, viscosity);
    liq = sdSmoothUnion(liq, sdSphere(p, vec3(2.,cos(ubo.totalTime+4.)*0.25,2.), particleSize, waterColor), 0.5, viscosity);
    return sdDisplacement(p, liq, 0.03125);
/*
    // start with the first particle
    LiquiSDD liq = sdSphere(p, particles[0].position.xyz, particles[0].position.w, particles[0].color.rgb);
    // how many particles?
    // combining all particles
    for(int i = 1; i < particleCount; i++)
    {
        // note, the k and n value change how smoothmin behaves, these values also allow us to simulate the viscosity
        // higher n means it can stretch further
        liq = sdSmoothUnion(liq, sdSphere(p, particles[i].position.xyz, particles[1].position.w, particles[i].color.rgb), 0.5, viscosity);
    }
    return liq;*/
 }

// get a sky color based on the ray direction
vec3 getSkyColor(in vec3 p, in vec3 rd)
{
    vec3 sunDir = normalize(ubo.sunPosition - p);
    // sky
    if(rd.y + sin(rd.x*20.) * sin(rd.z*20.)*0.125 <= -0.25)
    {
        return mix(lightColor, vec3(0.0, 0.25, 1.0), 0.5);
    }
    // mountain white
    else if(rd.y + sin(rd.x*7.5) * sin(rd.z*7.5)*0.0625 <= 0.)
    {
        return vec3(1.0, 1.0, 1.0);
    }
    // mountain grey
    else if(rd.y <= 0.5)
    {
        return vec3(0.6, 0.6, 0.6);
    }
    // sandy ground
    else if(rd.y > 0.5)
    {
        return vec3(0.8, 0.8, 0.0);
    }
}

vec3 ray_march(in vec3 ro, in vec3 rd)
{
    float total_distance_traveled = 0.0;
    float curr_distance_traveled = 0.0;
    const int NUMBER_OF_STEPS = 1024;
    const float MINIMUM_HIT_DISTANCE = 0.001;
    const float MAXIMUM_TRACE_DISTANCE = 1000.0;

    float unabsorbedEnergy = 1.f;

    vec3 color = vec3(0,0,0);
    bool inside = false;

    for (int i = 0; i < NUMBER_OF_STEPS; ++i)
    {
        vec3 current_position = ro + curr_distance_traveled * rd;

        LiquiSDD liq = map(current_position);
        float distance_to_closest = liq.val;

        if (distance_to_closest < MINIMUM_HIT_DISTANCE)
        {
            // entered first time
            if(!inside)
            {
                curr_distance_traveled = 0.0;
                // we now go down a new ray, the refracted ray, so we need to update our origin position
                ro = current_position;
                // refraction param: air=1.0, water=1.33, curr_medium / next_medium
                rd = refract(rd, liq.grad, 1. / refractionFactor);
                inside = true;
                // specular, reflection
                vec3 reflection = reflect(rd, liq.grad);
                color += specularFactor * pow(max(0., dot(reflection, normalize(ubo.sunPosition - current_position))), waterShininess) * lightColor;
            }
            float prevRestEnergy = unabsorbedEnergy;
            unabsorbedEnergy *= BeersLaw(energyAbsorption, density);

            total_distance_traveled += density;
            curr_distance_traveled += density;
            float absorptionThisStep = prevRestEnergy - unabsorbedEnergy;
            // diffuse light
            float distToLight = length(ubo.sunPosition - current_position);
            vec3 currLightColor = lightColor * intensity / distToLight; // attenuation function: 1/dist
            color += diffuseFactor * liq.col * currLightColor * absorptionThisStep;
            // ambient light
            color += ambientFactor * liq.col * ambientLight * absorptionThisStep;
            if(unabsorbedEnergy <= 0.f) 
            {
                break;
            }
        }
        else if( total_distance_traveled > MAXIMUM_TRACE_DISTANCE)
        {
            if(unabsorbedEnergy == 1.0)
            {
                // if this ray didn't go through liquid make it sky color
                return getSkyColor(current_position, rd);
            }
            else
            {
                // if the ray did go through liquid reduce the effect the sky has on the color
                return color + (unabsorbedEnergy) * getSkyColor(current_position, rd);
            }
        }
        else
        {
            total_distance_traveled += distance_to_closest;
            curr_distance_traveled += distance_to_closest;
            // refract when leaving
            if(inside)
            {
                // we now go down a new ray, the refracted ray, so we need to update our origin position
                ro = current_position;
                // refraction param: air=1.0, water=1.33, curr_medium / next_medium
                rd = refract(rd, liq.grad, 1. / refractionFactor);
                inside = false;
            }
        }
        
    }
    return color;
}

void main() {
    vec2 screenSize = imageSize(storageTexture);
    float horizontalCoefficient = (2.0 * float(gl_GlobalInvocationID.x) / screenSize.x) - 1.0;
    float verticalCoefficient = (2.0 * float(gl_GlobalInvocationID.y) / screenSize.y) - 1.0;

    vec3 ro = ubo.cameraPosition;
    vec3 rd = normalize(vec3(horizontalCoefficient, verticalCoefficient, -1.0));

    vec3 color = ray_march(ro, rd);

    imageStore(storageTexture, ivec2(gl_GlobalInvocationID.xy), vec4(color, 1.0));
}